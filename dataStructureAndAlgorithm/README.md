# dataStructureAndAlgorithm(データ構造とアルゴリズム)
講義科目である。
## 目的
講義科目「データ構造とアルゴリズム」の復習を行う  
## 手段
教科書「Javaで学ぶアルゴリズムとデータ構造 柴田望洋著 SBCreative」の内容及び講義の内容をMicrosoft Word 2016を用いて問題形式でまとめる。(note.docx)  
また、docxファイルはpdfファイルで公開する。([note.pdf](https://github.com/17ec084/grade2-2/raw/master/dataStructureAndAlgorithm/note.pdf))
## その他特筆すべき事項

### ポインタソート
聴講中に思いついた、新しい(？)並び替えアルゴリズム。  
コンセプトは単純明快である。  
1.並び変えたい0以上の整数を同じ(または比例する)番地のアドレスに格納する。  
2.空いた番地はつめる  
これで終わり。  
例えば表0のような配列をポインタソートすると、手順1で表1.1や表1.2のようになり、手順2で表2のようになってソートが完了する。  
<Div Align="center">表0 ソート前の配列  
<table>
  <tr>
    <th>アドレスまたは配列の番目</th>
    <th>0</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
  </tr>
  <tr>
    <td>0以上の整数</td>
    <td>1</td>
    <td>7</td>
    <td>14</td>
    <td>12</td>
    <td>0</td>
    <td>8</td>
    <td>4</td>
    <td>1</td>
  </tr>
</table></Div>  

まず、処理のため、数字をすべて右に移動する必要がある(※1)。(実際には配列の先頭要素のアドレスを小さくするだけでよいだろう)  
すると表1.1のようになる。
<Div Align="center">表1.1 ソート中の配列(手順1(1/2))
<table>
  <tr>
    <th>アドレスまたは配列の番目</th>
    <th>0</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
    <th>8</th>
    <th>9</th>
    <th>10</th>
    <th>11</th>
    <th>12</th>
    <th>13</th>
    <th>14</th>
    <th>15</th>
  </tr>
  <tr>
    <td>0以上の整数</td>
    <td>-2</td>
    <td>-2</td>
    <td>-2</td>
    <td>-2</td>
    <td>-2</td>
    <td>-2</td>
    <td>-2</td>
    <td>-1</td>
    <td>1</td>
    <td>7</td>
    <td>14</td>
    <td>12</td>
    <td>0</td>
    <td>8</td>
    <td>4</td>
    <td>1</td>
  </tr>
</table></Div>  

次に、0以上の整数を100倍して、整数に対応する番地において、インクリメントする。  
但し、移動先の番地にｰ2以外のものが入っていた場合は、整数が複数回出てくることを意味するので、インクリメントのみを行う。(※2)  
(※1の処理は、※2の処理の際に混乱が生じないために行った。  
8番目以降の要素に対しては依然として混乱が発生しうるが、今回は簡単に説明をするため無視する。)  
すると、表1.2のようになる。  
<Div Align="center">表1.2 ソート中の配列(手順1(2/2)) 
<table>
  <tr>
    <th>アドレスまたは配列の番目</th>
    <th>0</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
    <th>7</th>
    <th>8</th>
    <th>9</th>
    <th>10</th>
    <th>11</th>
    <th>12</th>
    <th>13</th>
    <th>14</th>
    <th>15</th>
  </tr>
  <tr>
    <td>0以上の整数</td>
    <td>1</td>
    <td>102</td>
    <td>-2</td>
    <td>-2</td>
    <td>401</td>
    <td>-2</td>
    <td>-2</td>
    <td>701</td>
    <td>801</td>
    <td>-2</td>
    <td>-2</td>
    <td>-2</td>
    <td>1201</td>
    <td>-2</td>
    <td>1401</td>
    <td>-3</td>
  </tr>
</table></Div>  

表1.2を見てみると、-2および-3以外の全ての整数は(配列の要素)×100+(出現回数)となっている。  
例えば整数1は表0に2回出てきているので、1×100+2=102となっているし、  
整数7は表0に2回出てきているので、7×100+1=701となっている。  
次に、-2が格納されている番地を左につめる。またその結果、-3が格納された番地より右の番地を切り捨てる。  
すると、表2.1のようにソート済みの配列が得られる。  
<Div Align="center">表2 ソート済の配列
<table>
  <tr>
    <th>アドレスまたは配列の番目</th>
    <th>0</th>
    <th>1</th>
    <th>2</th>
    <th>3</th>
    <th>4</th>
    <th>5</th>
    <th>6</th>
  </tr>
  <tr>
    <td>0以上の整数</td>
    <td>1</td>
    <td>102</td>
    <td>401</td>
    <td>701</td>
    <td>801</td>
    <td>1201</td>
    <td>1401</td>
  </tr>
</table></Div>
この結果の特徴として、重複があった場合には、一つにまとめ、さらにその回数を示すことで、あたかも『圧縮形式の配列』であるかのような配列を得ることができる。  
表0のような配列で、3番目に大きい整数を知りたい場合は、ポインタソート後にアドレス3に格納された整数を100で割った整数部分を得ればよいし、
0番目に大きい整数の出現回数を知りたい場合は、ポインタソート後にアドレス0に格納された整数を100で割った余りを得ればよい。  

